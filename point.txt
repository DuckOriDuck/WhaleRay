1. 환경 변수 처리 전략: ServiceID & Blob & Lambda Chaining 통합 모델 (Final)

1.1. 우리가 마주했던 고민 (Challenges)

- 시점의 딜레마 (Timing & Race Condition)
보안 격리를 위해 deploymentId를 키로 쓰고 싶었지만, 이 ID는 배포 버튼을 누른 후에 생성되어 빌드 시점과 엇갈릴 위험이 있었습니다.

- 휘발성 문제 (Persistence & UX)
deploymentId는 배포마다 바뀝니다. 이를 키로 쓰면 재배포할 때마다 .env 파일을 매번 다시 업로드해야 하는 최악의 UX가 발생합니다.

- 삭제의 모호성 (Deletion Ambiguity)
사용자가 환경 변수를 완전히 비우고 싶을 때, 단순히 내용을 비워서 보내면 시스템은 기존 값 유지로 오해하여 과거 변수가 계속 남는 좀비 변수 문제가 발생합니다.

- 단일 람다의 과부하 (Monolithic Responsibility)
기존 repo_inspector 람다가 코드 분석, SSM 암호화, CodeBuild 트리거까지 모든 책임을 떠안아 코드가 복잡해지고 디버깅이 어려웠습니다.


1.2. 해결 솔루션 (Our Solution)

위 문제들을 해결하기 위해 영속적 ID, 통 저장(Blob), 명시적 초기화, 그리고 람다 체이닝을 결합했습니다.

A. ServiceID 도입 (영속성 확보)
- 전략: 매번 바뀌는 deploymentId 대신, 변하지 않는 userId + repoName 조합을 serviceId로 정의하여 키로 사용합니다.
- 효과: 배포 전부터 키를 알 수 있어 시점 문제를 해결하고, 재배포 편의성을 확보합니다.

B. Blob 저장 방식 (파싱 제거)
- 전략: .env 내용을 파싱하지 않고, 전체 텍스트를 암호화된 하나의 덩어리(Blob)로 SSM에 저장합니다.
- 효과: 로직이 단순해지고 사용자가 작성한 포맷이 100% 보존됩니다.

C. 명시적 초기화 프로토콜 (Explicit Reset)
- 전략: 프론트엔드에서 isReset 플래그를 통해 유지와 삭제의 의도를 명확히 구분합니다.
- 효과: 사용자가 원할 때 확실하게 환경 변수를 비운 상태로 배포(Clean Deploy)할 수 있습니다.

D. 람다 체이닝 아키텍처 (Lambda Chaining)
- 전략: 거대해진 람다를 repo_inspector(분석가)와 env_builder(건축가)로 분리하고 비동기 호출로 연결합니다.
- 효과: 역할이 분리되어 코드 관리가 쉬워지고, 단계별 로그 추적 및 권한 격리(Security)가 가능해집니다.


1.3. 최종 아키텍처 흐름 (Architecture Flow)

1. Input (Frontend): 사용자가 .env 내용을 입력하거나 초기화 옵션을 선택하여 전송합니다.
2. Trigger (Deploy Lambda): 배포 정보를 DB에 저장합니다.
3. Analysis (Repo Inspector Lambda): DB 스트림을 받아 GitHub 코드를 분석하고 프레임워크를 감지합니다. 감지된 정보를 env_builder에게 넘깁니다 (Invoke).
4. Storage & Build (Env Builder Lambda): 넘겨받은 환경 변수 정보를 SSM에 저장/관리하고 CodeBuild를 시작합니다.
5. Injection (CodeBuild): CodeBuild는 SSM에서 DOTENV_BLOB을 가져와 .env 파일로 복원합니다.


1.4. 상세 로직 플로우 (Logic Flow)

Step 1. 입력 단계 (Frontend)
- 전송 데이터 구조:
  repoName: "my-app"
  envFileContent: "..." (또는 null)
  isReset: true/false (초기화 여부 플래그)

Step 2. 분석 단계 (Backend: Repo Inspector)
- 역할: 오직 GitHub API를 통해 프로젝트 언어(Spring/Node)만 식별합니다.
- 동작: 분석이 끝나면 { repoName, envFileContent, isReset, detectedFramework } 데이터를 담아 env_builder를 비동기 호출합니다.

Step 3. 저장 및 구축 단계 (Backend: Env Builder)
이 람다가 4단 우선순위 논리를 수행합니다.

(1) 초기화 확인: isReset이 true 인가?
   - YES: SSM에 빈 공백(" ")으로 덮어쓰기 (삭제 효과).

(2) 입력 확인: envFileContent가 있는가?
   - YES: SSM에 새 값으로 덮어쓰기(Put).

(3) 기존 설정 확인: (입력 없음, Reset 아님) SSM에 해당 serviceId 값이 있는가?
   - YES: 저장 건너뜀(Skip). (기존 값 사용)
   - NO: 이번이 첫 배포인데 환경변수를 안 줬음 -> 에러 반환 및 종료.

(4) 빌드 시작: 위 검증이 통과되면 detectedFramework에 맞는 CodeBuild 프로젝트를 실행합니다.

Step 4. 실행 단계 (CodeBuild)
- 주입: SSM에서 값을 가져옵니다. (초기화 시 공백이 옴)
- 복원: 빌드 루트에 .env 파일 생성.
- 결과: 빌드 성공 및 환경변수 없는 컨테이너 배포.


1.5. 시나리오별 동작 요약표

[상황: 초기화 (Reset)]
- 사용자 의도: 변수 다 지울래
- 요청 데이터: env=null, reset=true
- Env Builder 동작: SSM 빈 값 덮어쓰기
- 결과: (성공) 변수 없이 배포

[상황: 재배포 (Keep)]
- 사용자 의도: 기존 거 쓸래
- 요청 데이터: env=null, reset=false
- Env Builder 동작: 기존 SSM 유지 (Skip)
- 결과: (성공) 기존 변수 배포

[상황: 갱신 (Update)]
- 사용자 의도: 바꿀래
- 요청 데이터: env="A=1", reset=false
- Env Builder 동작: SSM 덮어쓰기 (Put)
- 결과: (성공) 새 변수 배포

[상황: 실수 (Error)]
- 사용자 의도: (초기배포 때 빈손)
- 요청 데이터: env=null, reset=false
- Env Builder 동작: SSM 없음 -> 에러
- 결과: (실패) 400 에러