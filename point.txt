## 1. 환경 변수 처리 전략: ServiceID & Blob 통합 모델

### 1.1. 우리가 마주했던 고민 (Challenges)

* **시점의 딜레마 (Timing & Race Condition)**
  * 보안 격리를 위해 `deploymentId`를 키로 쓰고 싶었지만, 이 ID는 배포 버튼을 누른 **후**에 생성됩니다.
  * CodeBuild가 시작되기 전 환경 변수가 세팅되어야 하는데, ID 생성 시점과 저장 시점이 꼬이면 빌드가 실패할 위험이 있었습니다.

* **휘발성 문제 (Persistence & UX)**
  * `deploymentId`는 배포마다 매번 바뀝니다(휘발성).
  * 이를 키로 사용하면 사용자는 재배포할 때마다 `.env` 파일을 **매번 다시 업로드**해야 하는 최악의 UX가 발생합니다.

* **파싱의 복잡함 (Parsing)**
  * 람다에서 `.env` 텍스트를 `KEY=VALUE`로 쪼개서 저장하려니, 주석(`#`), 따옴표(`"`), 공백 처리 등 예외 케이스가 너무 많아 로직이 비대해지고 불안정했습니다.

### 1.2. 해결 솔루션 (Our Solution)

위 문제들을 해결하기 위해 **"영속적 ID(ServiceID)"**와 **"통 저장(Blob)"** 전략을 결합했습니다.

#### A. ServiceID 도입 (영속성 확보)
* **전략:** 매번 바뀌는 `deploymentId` 대신, 변하지 않는 **`userId` + `repoName`** 조합을 `serviceId`로 정의하여 키로 사용합니다.
* **효과:**
  * **시점 문제 해결:** `repoName`은 배포 시작 전부터 알고 있는 값이므로, `deploymentId` 생성 시점과 무관하게 언제든 저장이 가능합니다.
  * **UX 혁신:** 키가 변하지 않으므로 한 번만 업로드하면, 다음 배포(재배포) 때는 입력 없이 기존 설정을 그대로 사용할 수 있습니다.

#### B. Blob 저장 방식 (파싱 제거)
* **전략:** `.env` 내용을 쪼개지 않고, **전체 텍스트를 암호화된 하나의 덩어리(Blob)**로 SSM에 저장합니다.
* **효과:**
  * **로직 단순화:** 복잡한 파싱 코드가 사라지고, 단순히 `Save` & `Load`만 남습니다.
  * **무결성:** 사용자가 작성한 포맷(주석, 특수문자 등)이 100% 그대로 보존되어 컨테이너에 전달됩니다.

### 1.3. 최종 아키텍처 흐름 (Architecture Flow)

1.  **Input (Frontend):**
  * 사용자가 `.env` 내용을 통째로 붙여넣거나 파일을 드래그합니다. (Git 업로드 X, HTTPS 전송)
2.  **Storage (Lambda -> SSM):**
  * `repo_inspector` 람다가 내용을 받아서 `/{Project}/{UserId}/{RepoName}/DOTENV_BLOB` 경로에 KMS로 암호화하여 저장(`PutParameter`)합니다.
3.  **Injection (CodeBuild):**
  * CodeBuild가 시작되면 SSM에서 `DOTENV_BLOB` 파라미터 하나만 가져옵니다.
  * 이 내용을 빌드 디렉토리 루트에 **`.env` 파일로 복원(Write)**합니다.
  * Spring/Node.js가 실행되면서 이 파일을 자연스럽게 읽어들입니다.

### 1.4. 상세 로직 플로우 (Logic Flow)

이 흐름은 **사용자 편의성(재배포 시 입력 생략)**과 **시스템 안정성(초기 배포 필수 입력)**을 모두 만족시킵니다.

#### Step 1. 입력 단계 (Frontend)
* **사용자 행동:** 레포지토리를 선택하고, `.env` 내용을 입력하거나 비워둔 채 **[배포하기]** 버튼을 클릭합니다.
* **전송 데이터:** `{ repoName: "my-app", envFileContent: "..." (또는 null) }`

#### Step 2. 검증 및 저장 단계 (Backend: Repo Inspector Lambda)
람다는 다음 **3단 논리**로 작동하여 초기 배포와 재배포를 구분합니다.

1.  **입력 확인:** `envFileContent`가 있는가?
  * **YES (있다):** 사용자가 설정을 바꾸고 싶어 함 → SSM에 **덮어쓰기(Put)** 진행.
  * **NO (없다):** 재배포 의도임 → 다음 단계(2번)로 이동.
2.  **기존 설정 확인:** (입력이 없을 때) SSM에 해당 `serviceId`(`UserId/RepoName`)로 저장된 파라미터가 이미 있는가?
  * **YES (있다):** 이미 배포한 적이 있음 → 저장 **건너뜀(Skip)** & 빌드 진행.
  * **NO (없다):** 이번이 첫 배포인데 환경변수를 안 줬음 → **🚫 에러 반환 (400 Bad Request)**
  * *에러 메시지: "초기 배포 시에는 환경 변수(.env) 입력이 필수입니다."*
3.  **빌드 트리거:** 검증이 통과되면 CodeBuild를 시작합니다.

#### Step 3. 실행 단계 (CodeBuild)
* **주입:** 시작되자마자 SSM에서 `DOTENV_BLOB`을 가져옵니다.
* **복원:** 가져온 텍스트를 빌드 환경 루트에 `.env` 파일로 생성합니다.

### 1.5. 시나리오별 동작 요약표

| 상황 | 사용자 입력 (.env) | 백엔드 동작 | 결과 |
| :--- | :--- | :--- | :--- |
| **초기 배포 (First)** | **입력함 (O)** | SSM 저장 (New) | ✅ **배포 성공** |
| **초기 배포 (First)** | **비워둠 (X)** | SSM 없음 → 검증 실패 | ❌ **배포 거부 (Error)** |
| **재배포 (Re-deploy)** | **비워둠 (X)** | SSM 확인됨 → 저장 Skip | ✅ **기존 설정 유지** |
| **설정 변경 (Update)** | **입력함 (O)** | SSM 저장 (Overwrite) | ✅ **새 설정 적용** |