version: 0.2
phases:
  pre_build:
    commands:
      - |
        echo "=== Enhanced Spring Boot Gradle Build Started ==="
        echo "Build Environment Variables:"
        echo "  Source Directory: $SOURCE_DIR"
        echo "  Build Context: $BUILD_CONTEXT"
        echo "  Dockerfile Path: $DOCKERFILE_PATH"
        echo "  Has Gradle Wrapper: $HAS_GRADLE_WRAPPER"
      - echo "Logging in to Amazon ECR..."
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
      - echo "Restoring .env file from SSM if provided..."
      - if [ -n "$DOTENV_BLOB_SSM_PATH" ]; then aws ssm get-parameter --name "$DOTENV_BLOB_SSM_PATH" --with-decryption --query Parameter.Value --output text > .env && echo "Successfully restored .env file."; else echo ".env file not provided, skipping."; fi
  build:
    commands:
      - echo "Build started for Spring Boot on `date`"
      - echo "Initial directory:" && pwd && ls -la
      - |
        # Step 1: Navigate to source directory for Gradle build
        if [ -n "$SOURCE_DIR" ] && [ "$SOURCE_DIR" != "." ]; then
          echo "Changing to source directory: $SOURCE_DIR"
          cd $SOURCE_DIR
          echo "Current directory after cd: $(pwd)"
          echo "Contents:" && ls -la
        else
          echo "Building in root directory"
        fi
      - |
        # Step 2: Execute Gradle build with wrapper detection
        echo "Building Spring Boot application..."
        if [ ! -f "build.gradle" ]; then
          echo "ERROR: No build.gradle found in current directory"
          exit 1
        fi
        
        echo "Found build.gradle, proceeding with build..."
        if [ "$HAS_GRADLE_WRAPPER" = "true" ] && [ -f "gradlew" ]; then
          echo "Using Gradle Wrapper"
          chmod +x gradlew
          ./gradlew clean build -x test --no-daemon
        else
          echo "Using system Gradle (no wrapper found)"
          gradle clean build -x test --no-daemon
        fi
        
        echo "Gradle build completed successfully"
        echo "Build artifacts:" && find build -name "*.jar" -type f 2>/dev/null || echo "No JAR files found"
      - |
        # Step 3: Navigate to build context for Docker operations
        if [ -n "$BUILD_CONTEXT" ] && [ "$BUILD_CONTEXT" != "$(basename $(pwd))" ]; then
          echo "Changing to build context: $BUILD_CONTEXT"
          cd $CODEBUILD_SRC_DIR/$BUILD_CONTEXT
          echo "Current directory for Docker build: $(pwd)"
          echo "Contents:" && ls -la
        else
          echo "Docker build context is current directory"
        fi
      - |
        # Step 4: Handle Dockerfile - use discovered or auto-generate
        FINAL_DOCKERFILE_PATH=""
        
        if [ -n "$DOCKERFILE_PATH" ] && [ "$DOCKERFILE_PATH" != "" ]; then
          # Use discovered Dockerfile path (relative to build context)
          if [ "$BUILD_CONTEXT" != "." ] && [[ "$DOCKERFILE_PATH" == "$BUILD_CONTEXT"* ]]; then
            # Remove build context prefix from dockerfile path
            RELATIVE_DOCKERFILE_PATH=${DOCKERFILE_PATH#$BUILD_CONTEXT/}
            FINAL_DOCKERFILE_PATH="$RELATIVE_DOCKERFILE_PATH"
          else
            FINAL_DOCKERFILE_PATH="$DOCKERFILE_PATH"
          fi
          
          if [ -f "$FINAL_DOCKERFILE_PATH" ]; then
            echo "Using discovered Dockerfile: $FINAL_DOCKERFILE_PATH"
          else
            echo "WARNING: Discovered Dockerfile not found at $FINAL_DOCKERFILE_PATH, auto-generating..."
            FINAL_DOCKERFILE_PATH="Dockerfile"
          fi
        else
          echo "No Dockerfile discovered, auto-generating..."
          FINAL_DOCKERFILE_PATH="Dockerfile"
        fi
        
        # Auto-generate Dockerfile if needed
        if [ ! -f "$FINAL_DOCKERFILE_PATH" ]; then
          echo "Creating optimized Dockerfile for Spring Boot..."
          echo 'FROM eclipse-temurin:17-jre-alpine' > "$FINAL_DOCKERFILE_PATH"
          echo '# Create non-root user for security' >> "$FINAL_DOCKERFILE_PATH"
          echo 'RUN addgroup -g 1001 -S spring && adduser -u 1001 -S spring -G spring' >> "$FINAL_DOCKERFILE_PATH"
          echo 'WORKDIR /app' >> "$FINAL_DOCKERFILE_PATH"
          echo '# Copy JAR file (support both single and multiple JAR scenarios)' >> "$FINAL_DOCKERFILE_PATH"
          echo 'COPY build/libs/*.jar app.jar' >> "$FINAL_DOCKERFILE_PATH"
          echo '# Set ownership' >> "$FINAL_DOCKERFILE_PATH"
          echo 'RUN chown -R spring:spring /app' >> "$FINAL_DOCKERFILE_PATH"
          echo 'USER spring' >> "$FINAL_DOCKERFILE_PATH"
          echo 'EXPOSE 8080' >> "$FINAL_DOCKERFILE_PATH"
          echo '# Use exec form for better signal handling' >> "$FINAL_DOCKERFILE_PATH"
          echo 'ENTRYPOINT ["java", "-jar", "app.jar"]' >> "$FINAL_DOCKERFILE_PATH"
          echo "Created optimized Dockerfile with security best practices"
        fi
        
        echo "Final Dockerfile path: $FINAL_DOCKERFILE_PATH"
        echo "Dockerfile contents:"
        cat "$FINAL_DOCKERFILE_PATH"
      - |
        # Step 5: Build Docker image with proper context
        echo "Building Docker image..."
        echo "Docker build context: $(pwd)"
        echo "Dockerfile: $FINAL_DOCKERFILE_PATH"
        
        # Build with proper context - current directory is already the build context
        docker build -f "$FINAL_DOCKERFILE_PATH" -t $ECR_IMAGE_URI .
        
        echo "Docker image built successfully"
  post_build:
    commands:
      - echo "Pushing Docker image to ECR..."
      - docker push $ECR_IMAGE_URI
      - echo "Build and push completed successfully"